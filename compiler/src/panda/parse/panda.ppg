// Assumes polyglot.jar is in classpath
include "polyglot/ext/jl7/parse/jl7.ppg"

package panda.parse;

import panda.types.PandaTypeSystem;
import panda.ast.PandaNodeFactory;
import panda.ast.*;
import polyglot.parse.Name;
import polyglot.parse.VarDeclarator;

parser Grm extends polyglot.ext.jl7.parse.Grm {:
  public final PandaTypeSystem ts;
  public final PandaNodeFactory nf;

  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
      super(l, t, n, q);
      ts = (PandaTypeSystem) t;
      nf = (PandaNodeFactory) n;
  } 
  
:};

terminal Token MODE; 
terminal Token MODES;
terminal Token PARORD;

non terminal ModesDecl modes_declaration_opt;
non terminal ModesDecl modes_declaration;
non terminal ModeOrder mode_ordering;
non terminal List mode_orderings;

non terminal List mode_type_parameters_decl_opt;
non terminal List mode_type_parameters_decl;
non terminal List mode_type_parameters;
non terminal ModeParamTypeNode mode_type_parameter;

non terminal List<ModeTypeNode> mode_type_args;

non terminal ModeTypeNode mode_type_node;
non terminal List<ModeTypeNode> mode_type_nodes;
non terminal List<ModeTypeNode> mode_type_inst;

//precedence left IDENTIFIER;
//precedence left MODE;

start with goal;


override compilation_unit ::=
                    // SourceFile
  package_declaration_opt:p import_declarations_opt:i modes_declaration_opt:m type_declarations_opt:t 
  {: 
    RESULT = parser.nf.SourceFile(new Position(parser.lexer.path(), 
                                               parser.lexer.file()), 
                                  p, 
                                  i, 
                                  t,
                                  m);
  :}
| error type_declarations_opt:c
  {: RESULT = parser.nf.SourceFile(new Position(parser.lexer.path(), 
                                                parser.lexer.file()), 
                                   null, 
                                   Collections.<Import> emptyList(), 
                                   c, 
                                   null);
  :}
;

modes_declaration_opt ::=
  modes_declaration:m
  {: RESULT = m; :}
|
  {: RESULT = null; :}
;

modes_declaration ::=
  MODES LBRACE:lb mode_orderings:ords RBRACE:rb
  {:
    RESULT = parser.nf.ModesDecl(parser.pos(lb, rb), ords);
  :}
;

mode_orderings ::=
  {: RESULT = new ArrayList(); :}
| mode_orderings:ords mode_ordering:m
  {: 
    RESULT = ords;
    ords.add(m);
  :}
;
  
mode_ordering ::=
  IDENTIFIER:lower PARORD IDENTIFIER:upper SEMICOLON:semi
  {: RESULT = 
    parser.nf.ModeOrder(parser.pos(lower, semi), 
                        lower.getIdentifier(), 
                        upper.getIdentifier()); 
  :}
;

override class_declaration ::=
  modifiers_or_annotations_opt:a CLASS:n IDENTIFIER:b type_parameters_opt:c mode_type_parameters_decl_opt:m super_opt:d interfaces_opt:e class_body:f
  {: 
    RESULT = parser.nf.ClassDecl(parser.pos(n, e),  
                                a.flags(), 
                                a.annotations(), 
                                parser.nf.Id(parser.pos(b), b.getIdentifier()), 
                                d, 
                                e, 
                                f, 
                                c,
                                m); 
  :}
;    

// 19.8.5) Constructor Declarations
override constructor_declaration ::=
  modifiers_or_annotations_opt:a simple_name:d LPAREN formal_parameter_list_opt:e RPAREN  throws_opt:f constructor_body:g
  {: 
    RESULT = parser.nf.ConstructorDecl(d.pos, a.flags(), a.annotations(), d.name, e, f, g, new LinkedList<ParamTypeNode>(), new ArrayList<ModeParamTypeNode>()); 
  :}
| modifiers_or_annotations_opt:a mode_type_parameters_decl:m simple_name:d LPAREN formal_parameter_list_opt:e RPAREN  throws_opt:f constructor_body:g
  {: 
    RESULT = parser.nf.ConstructorDecl(d.pos, a.flags(), a.annotations(), d.name, e, f, g, new LinkedList<ParamTypeNode>(), m); 
  :}
| modifiers_or_annotations_opt:a LT type_parameter_list_1:c simple_name:d LPAREN formal_parameter_list_opt:e RPAREN throws_opt:f constructor_body:g
  {: 
    RESULT = parser.nf.ConstructorDecl(d.pos, a.flags(), a.annotations(), d.name, e, f, g, c, new ArrayList<ModeParamTypeNode>()); 
  :} 
| modifiers_or_annotations_opt:a LT type_parameter_list_1:c mode_type_parameters_decl:m simple_name:d LPAREN formal_parameter_list_opt:e RPAREN throws_opt:f constructor_body:g
  {: 
    RESULT = parser.nf.ConstructorDecl(d.pos, a.flags(), a.annotations(), d.name, e, f, g, c, m); 
  :} 
; 

override method_header ::=
  modifiers_or_annotations_opt:a type:b IDENTIFIER:d LPAREN formal_parameter_list_opt:e RPAREN dims_opt:g throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(b, g, d), a.flags(), a.annotations(), parser.array(b, g.intValue()), parser.nf.Id(parser.pos(d), d.getIdentifier()), e, h, null, new LinkedList<ParamTypeNode>(), new ArrayList<ModeParamTypeNode>()); 
  :}
| modifiers_or_annotations_opt:a mode_type_parameters_decl:m type:b IDENTIFIER:d LPAREN formal_parameter_list_opt:e RPAREN dims_opt:g throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(b, g, d), a.flags(), a.annotations(), parser.array(b, g.intValue()), parser.nf.Id(parser.pos(d), d.getIdentifier()), e, h, null, new LinkedList<ParamTypeNode>(), m); 
  :}
| modifiers_or_annotations_opt:a LT type_parameter_list_1:c type:d IDENTIFIER:i LPAREN formal_parameter_list_opt:e RPAREN dims_opt:g throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(d, g, i), a.flags(), a.annotations(), parser.array(d, g.intValue()), parser.nf.Id(parser.pos(i), i.getIdentifier()), e, h, null, c, new ArrayList<ModeParamTypeNode>()); 
  :}
| modifiers_or_annotations_opt:a LT type_parameter_list_1:c mode_type_parameters_decl:m type:d IDENTIFIER:i LPAREN formal_parameter_list_opt:e RPAREN dims_opt:g throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(d, g, i), a.flags(), a.annotations(), parser.array(d, g.intValue()), parser.nf.Id(parser.pos(i), i.getIdentifier()), e, h, null, c, m); 
  :} 
| modifiers_or_annotations_opt:a VOID:b IDENTIFIER:c LPAREN formal_parameter_list_opt:e RPAREN:f throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(b, f, c), a.flags(), a.annotations(), parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), parser.nf.Id(parser.pos(c), c.getIdentifier()), e, h, null, new LinkedList<ParamTypeNode>(), new ArrayList<ModeParamTypeNode>()); 
  :}
| modifiers_or_annotations_opt:a mode_type_parameters_decl:m VOID:b IDENTIFIER:c LPAREN formal_parameter_list_opt:e RPAREN:f throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(b, f, c), a.flags(), a.annotations(), parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), parser.nf.Id(parser.pos(c), c.getIdentifier()), e, h, null, new LinkedList<ParamTypeNode>(), m); 
  :}
| modifiers_or_annotations_opt:a LT type_parameter_list_1:c VOID:d IDENTIFIER:i LPAREN formal_parameter_list_opt:e RPAREN:f throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(d, f, i), a.flags(), a.annotations(), parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), parser.nf.Id(parser.pos(i), i.getIdentifier()), e, h, null, c, new ArrayList<ModeParamTypeNode>()); 
  :}
| modifiers_or_annotations_opt:a LT type_parameter_list_1:c mode_type_parameters_decl:m VOID:d IDENTIFIER:i LPAREN formal_parameter_list_opt:e RPAREN:f throws_opt:h
  {: 
    RESULT = parser.nf.MethodDecl(parser.pos(d, f, i), a.flags(), a.annotations(), parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), parser.nf.Id(parser.pos(i), i.getIdentifier()), e, h, null, c, m); 
  :}
; 

mode_type_parameters_decl_opt ::=
  mode_type_parameters_decl:m
  {: RESULT = m; :}
| /* empty */
  {: RESULT = null; :}
;

mode_type_parameters_decl ::=
  MODE LT mode_type_parameters:params GT
  {: RESULT = params; :}
;

mode_type_parameters ::=
  mode_type_parameter:m
  {: 
    List<ModeParamTypeNode> params = new ArrayList<ModeParamTypeNode>();
    params.add(m);
    RESULT = params;
  :}
| mode_type_parameters:params COMMA mode_type_parameter:m
  {: 
    RESULT = params;
    params.add(m);
  :}
;

mode_type_parameter ::=
  IDENTIFIER:id
  {: 
    RESULT = 
      parser.nf.ModeParamTypeNode(parser.pos(id), 
                                  parser.nf.Id(parser.pos(id), id.getIdentifier()));
  :}
;

override class_or_interface_type ::=
  class_or_interface:a
  {: 
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(a), a);
  :}
|	class_or_interface:a LT type_argument_list_1:c
  {: 
    TypeNode n = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a, c); 
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(n), n);
  :}
| class_or_interface:a mode_type_args:args
  {: 
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(a), a, args);
  :}
|	class_or_interface:a LT type_argument_list_1:c mode_type_args:args
  {: 
    TypeNode n = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a, c); 
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(n), n, args);
  :}
;

override primitive_type ::=
  numeric_type:a
  {:
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(a), a);
  :}
| BOOLEAN:a
  {:
    TypeNode n = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean());
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(n), n);
  :}
| numeric_type:a mode_type_args:args
  {: 
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(a), a, args);
  :}
| BOOLEAN:a mode_type_args:args
  {: 
    TypeNode n = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean()); 
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(n), n, args);
  :}
;

mode_type_args ::=
  MODE LT mode_type_nodes:nodes GT
  {:
    RESULT = nodes;
  :}
; 

mode_type_nodes ::=
  mode_type_node:n
  {:
    List<ModeTypeNode> nodes = new ArrayList<ModeTypeNode>();
    nodes.add(n);
    RESULT = nodes;
  :}
| mode_type_nodes:nodes COMMA mode_type_node:n
  {:
    nodes.add(n);
    RESULT = nodes;
  :}
;

mode_type_node ::=
  IDENTIFIER:id
  {:
    RESULT = parser.nf.ModeTypeNode(parser.pos(id), id.getIdentifier());
  :}
| MULT:m
  {:
    RESULT = parser.nf.ModeTypeNode(parser.pos(m), "*");
  :}
;

