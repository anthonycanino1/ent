// Assumes polyglot.jar is in classpath
include "polyglot/ext/jl7/parse/jl7.ppg"

package panda.parse;

import panda.types.PandaTypeSystem;
import panda.ast.PandaNodeFactory;
import panda.ast.*;
import polyglot.parse.Name;
import polyglot.parse.VarDeclarator;

parser Grm extends polyglot.ext.jl7.parse.Grm {:
  public final PandaTypeSystem ts;
  public final PandaNodeFactory nf;

  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
      super(l, t, n, q);
      ts = (PandaTypeSystem) t;
      nf = (PandaNodeFactory) n;
  } 
  
:};

terminal Token MODE; 
terminal Token MODES;
terminal Token PARORD;

non terminal ModesDecl modes_declaration_opt;
non terminal ModesDecl modes_declaration;
non terminal ModeOrder mode_ordering;
non terminal List mode_orderings;

non terminal List mode_type_parameters_decl_opt;
non terminal List mode_type_parameters_decl;
non terminal List mode_type_parameters;
non terminal ModeParamTypeNode mode_type_parameter;

non terminal ModeTypeNode mode_type_decl;
non terminal ModeTypeNode mode_type_node;
non terminal List<ModeTypeNode> mode_type_nodes;
non terminal List<ModeTypeNode> mode_type_inst;

//precedence left IDENTIFIER;
//precedence left MODE;

start with goal;


override compilation_unit ::=
                    // SourceFile
  package_declaration_opt:p import_declarations_opt:i modes_declaration_opt:m type_declarations_opt:t 
  {: 
    RESULT = parser.nf.SourceFile(new Position(parser.lexer.path(), 
                                               parser.lexer.file()), 
                                  p, 
                                  i, 
                                  t,
                                  m);
  :}
| error type_declarations_opt:c
  {: RESULT = parser.nf.SourceFile(new Position(parser.lexer.path(), 
                                                parser.lexer.file()), 
                                   null, 
                                   Collections.<Import> emptyList(), 
                                   c, 
                                   null);
  :}
;

modes_declaration_opt ::=
  modes_declaration:m
  {: RESULT = m; :}
|
  {: RESULT = null; :}
;

modes_declaration ::=
  MODES LBRACE:lb mode_orderings:ords RBRACE:rb
  {:
    RESULT = parser.nf.ModesDecl(parser.pos(lb, rb), ords);
  :}
;

mode_orderings ::=
  {: RESULT = new ArrayList(); :}
| mode_orderings:ords mode_ordering:m
  {: 
    RESULT = ords;
    ords.add(m);
  :}
;
  
mode_ordering ::=
  IDENTIFIER:lower PARORD IDENTIFIER:upper SEMICOLON:semi
  {: RESULT = 
    parser.nf.ModeOrder(parser.pos(lower, semi), 
                        lower.getIdentifier(), 
                        upper.getIdentifier()); 
  :}
;

override class_declaration ::=
  modifiers_or_annotations_opt:a CLASS:n IDENTIFIER:b type_parameters_opt:c mode_type_parameters_decl_opt:m super_opt:d interfaces_opt:e class_body:f
  {: 
    RESULT = parser.nf.ClassDecl(parser.pos(n, e),  
                                a.flags(), 
                                a.annotations(), 
                                parser.nf.Id(parser.pos(b), b.getIdentifier()), 
                                d, 
                                e, 
                                f, 
                                c,
                                m); 
  :}
;    

mode_type_parameters_decl_opt ::=
  mode_type_parameters_decl:m
  {: RESULT = m; :}
| /* empty */
  {: RESULT = null; :}
;

mode_type_parameters_decl ::=
  MODE LT mode_type_parameters:params GT
  {: RESULT = params; :}
;

mode_type_parameters ::=
  mode_type_parameter:m
  {: 
    List<ModeParamTypeNode> params = new ArrayList<ModeParamTypeNode>();
    params.add(m);
    RESULT = params;
  :}
| mode_type_parameters:params COMMA mode_type_parameter:m
  {: 
    RESULT = params;
    params.add(m);
  :}
;

mode_type_parameter ::=
  IDENTIFIER:id
  {: 
    RESULT = 
      parser.nf.ModeParamTypeNode(parser.pos(id), 
                                  parser.nf.Id(parser.pos(id), id.getIdentifier()));
  :}
;

extend class_or_interface_type ::=
  class_or_interface:a mode_type_decl:m GT
  {: 
    PandaTypeNodeExt ext = (PandaTypeNodeExt) PandaExt.ext(a);
    ext.modeTypeNode(m);
    RESULT = a; 
  :}
|	class_or_interface:a LT type_argument_list_1:c mode_type_decl:m GT
  // Instantiating type arguments
  {: 
    TypeNode n = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a, c); 
    PandaTypeNodeExt ext = (PandaTypeNodeExt) PandaExt.ext(n);
    ext.modeTypeNode(m);
    RESULT = n;
  :}
| class_or_interface:a mode_type_decl:m mode_type_inst:nodes
  {: 
    PandaTypeNodeExt ext = (PandaTypeNodeExt) PandaExt.ext(a);
    ext.modeTypeNode(m);
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(a), a, nodes);
  :}
|	class_or_interface:a LT type_argument_list_1:c mode_type_decl:m mode_type_inst:nodes
  // Instantiating type arguments
  {: 
    TypeNode n = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a, c); 
    PandaTypeNodeExt ext = (PandaTypeNodeExt) PandaExt.ext(n);
    ext.modeTypeNode(m);
    RESULT = parser.nf.AmbModeTypeInstantiation(parser.pos(n), n, nodes);
  :}
;

extend primitive_type ::=
  numeric_type:a mode_type_decl:m GT
  {: 
    PandaTypeNodeExt ext = (PandaTypeNodeExt) PandaExt.ext(a); 
    ext.modeTypeNode(m); 
    RESULT = a; 
  :}
  | BOOLEAN:a mode_type_decl:m GT
  {: 
    TypeNode n = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean()); 
    PandaTypeNodeExt ext = (PandaTypeNodeExt) PandaExt.ext(n);
    ext.modeTypeNode(m);
    RESULT = n;
  :}
;

mode_type_decl ::=
  MODE LT mode_type_node:n 
  {:
    RESULT = n;
  :}
; 

mode_type_inst ::=
  COMMA mode_type_nodes:n GT
  {:
    RESULT = n;
  :}
; 

mode_type_nodes ::=
  mode_type_node:n
  {: 
    List<ModeTypeNode> nodes = new ArrayList<ModeTypeNode>();
    nodes.add(n);
    RESULT = nodes;
  :}
| mode_type_nodes:nodes COMMA mode_type_node:n
  {:
    nodes.add(n);
    RESULT = nodes;
  :}
;

mode_type_node ::=
  IDENTIFIER:id
  {:
    RESULT = parser.nf.ModeTypeNode(parser.pos(id), id.getIdentifier());
  :}
;

